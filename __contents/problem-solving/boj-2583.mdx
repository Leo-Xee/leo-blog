---
title: 백준 2583 - 영역 구하기
description:
thumbnail:
tags: ['Baekjoon', 'DFS', 'BFS']
createdAt: 2025-08-20T09:14:34.600Z
---

## 문제 링크

[2583 - 영역 구하기](https://www.acmicpc.net/problem/2583)

## 사용 알고리즘

- DFS
- BFS

## 시간 복잡도

- $O(MN)$

## 문제 풀이

1. 직사각형의 개수(`k`)만큼 순회한다.
   1. 좌측 하단(`cx1`, `cy1`)과 우측 상단(`cx2`, `cy2`)으로 이루어진 직사각형 영역을 맵(`a`)에 `1`로 표시한다.
2. `a`의 특정 좌표가 `0`이고 방문하지 않은 경우에 BFS를 수행한다.
   1. 특정 좌표를 방문할 때마다 분리된 영역의 넓이(`area`)를 `1`만큼 증가시키고 최종값을 반환한다.
3. `area`의 개별 값들을 분리된 영역의 넓이를 모아둘 벡터(`ret`)에 추가한다.
4. `ret`을 오름차순 정렬한다.
5. `ret`의 길이와 각 요소를 출력한다.

### C++

```cpp title="C++"
#include <bits/stdc++.h>
using namespace std;

const int dy[] = {-1, 0, 1, 0};
const int dx[] = {0, 1, 0, -1};

int m, n, k, cx1, cy1, cx2, cy2;
int a[104][104], visited[104][104];
vector<int> ret;

int bfs(int y, int x) {
  queue<pair<int, int>> q;
  visited[y][x] = 1;
  q.push({y, x});

  int area = 0;

  while (q.size()) {
    tie(y, x) = q.front();
    q.pop();
    area++;
    for (int i = 0; i < 4; i++) {
      int ny = y + dy[i];
      int nx = x + dx[i];
      if (ny < 0 || ny >= m || nx < 0 || nx >= n) continue;
      if (!a[ny][nx] && !visited[ny][nx]) {
        visited[ny][nx] = 1;
        q.push({ny, nx});
      }
    }
  }

  return area;
}

int main() {
  cin >> m >> n >> k;

  for (int i = 0; i < k; i++) {
    cin >> cx1 >> cy1 >> cx2 >> cy2;

    // 좌표 간의 구간을 배열로 변환 시에 범위 주의!
    for (int y = cy1; y < cy2; y++) {
      for (int x = cx1; x < cx2; x++) {
        a[y][x] = 1;
      }
    }
  }

  for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
      if (!a[i][j] && !visited[i][j]) {
        ret.push_back(bfs(i, j));
      }
    }
  }

  sort(ret.begin(), ret.end());
  cout << ret.size() << "\n";
  for (int it : ret) cout << it << " ";

  return 0;
}
```

### JavaScript

```js title="JavaScript"
const fs = require('fs');
const filePath = process.platform === 'linux' ? '/dev/stdin' : '../input.txt';
const input = fs.readFileSync(filePath).toString().trim().split('\n');

const [M, N, _] = input
  .shift()
  .split(' ')
  .map((v) => +v);
const curs = input.map((v) => v.split(' ').map((v) => +v));

const dy = [-1, 0, 1, 0];
const dx = [0, 1, 0, -1];

const a = [...Array(M)].map(() => Array(N).fill(0));
const vis = [...Array(M)].map(() => Array(N).fill(0));
const ret = [];

const bfs = (y, x) => {
  const q = [];
  vis[y][x] = 1;
  q.push([y, x]);

  let area = 0;

  while (q.length) {
    [y, x] = q.shift();
    area++;
    for (let i = 0; i < 4; i++) {
      const ny = y + dy[i];
      const nx = x + dx[i];
      if (ny < 0 || ny >= M || nx < 0 || nx >= N) continue;
      if (!a[ny][nx] && !vis[ny][nx]) {
        vis[ny][nx] = 1;
        q.push([ny, nx]);
      }
    }
  }
  return area;
};

for (let cur of curs) {
  [x1, y1, x2, y2] = cur;

  for (let i = y1; i < y2; i++) {
    for (let j = x1; j < x2; j++) {
      a[i][j] = 1;
    }
  }
}

for (let i = 0; i < M; i++) {
  for (let j = 0; j < N; j++) {
    if (!a[i][j] && !vis[i][j]) {
      ret.push(bfs(i, j));
    }
  }
}

ret.sort((a, b) => a - b);
console.log(ret.length);
console.log(ret.join(' '));
```
