---
title: 백준 11724 - 연결 요소의 개수
description:
thumbnail:
tags: ['Baekjoon', 'DFS', 'BFS']
createdAt: 2025-08-21T06:51:17.676Z
---

## 문제 링크

[11724 - 연결 요소의 개수](https://www.acmicpc.net/problem/11724)

## 사용 알고리즘

- DFS
- BFS

## 시간 복잡도

- $O(N + M)$

## 문제 풀이

### C++

```cpp title="C++"
#include <bits/stdc++.h>
using namespace std;

int n, m, from, to, visited[1004], cnt;
vector<int> adj[1004];

void dfs(int here) {
  visited[here] = 1;
  for (int there : adj[here]) {
    if (!visited[there]) {
      dfs(there);
    }
  }
}

int main() {
  cin >> n >> m;
  for (int i = 0; i < m; i++) {
    cin >> from >> to;
    adj[from].push_back(to);
    adj[to].push_back(from);
  }

  for (int i = 1; i <= n; i++) {  // 범위 실수 주의!
    if (!visited[i]) {
      dfs(i);
      cnt++;
    }
  }

  cout << cnt << "\n";

  return 0;
}
```

### JavaScript

```js title="JavaScript"
const fs = require('fs');
const filePath = process.platform === 'linux' ? '/dev/stdin' : '../input.txt';
const input = fs.readFileSync(filePath).toString().trim().split('\n');

const [N, _] = input
  .shift()
  .split(' ')
  .map((v) => +v);

const adj = Array.from({ length: N + 1 }, () => []);
const vis = Array.from({ length: N + 1 }, () => 0);
const edges = input.map((v) => v.split(' ').map((v) => +v));
let cnt = 0;

const dfs = (here) => {
  vis[here] = 1;
  for (let there of adj[here]) {
    if (!vis[there]) {
      dfs(there);
    }
  }
};

for (let [from, to] of edges) {
  adj[from].push(to);
  adj[to].push(from);
}

for (let i = 1; i <= N; i++) {
  if (!vis[i]) {
    dfs(i);
    cnt++;
  }
}

console.log(cnt);
```
