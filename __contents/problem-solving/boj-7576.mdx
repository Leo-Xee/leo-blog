---
title: 백준 7576 - 토마토
description:
thumbnail:
tags: ['BaekJoon', 'BFS']
createdAt: 2025-02-21T14:21:12.729Z
---

## 문제 링크

[7576 - 토마토](https://www.acmicpc.net/problem/7576)

## 사용 알고리즘

- BFS

## 시간 복잡도

- $O(NM)$

## 문제 풀이

이 문제는 BFS를 활용하는 문제이며 자바스크립트의 경우 `array.shift()`를 사용하면 시간초과가 발생해서 인덱스를 조정하는 방식으로 풀었습니다.

문제 풀이의 과정은 아래와 같습니다.

1. 토마토 상자의 크기 만큼 입력 받기
   1. 익은 토마토인 경우 큐에 추가
   2. 익지 않은 토마토인 경우 방문 배열에 `-1` 저장
2. 큐가 빌 때까지 순회
   1. 큐에서 요소를 꺼내서 상하좌우 탐색
   2. 탐색한 위치가 익지 않은 토마토인 경우 방문 배열에 `1` 증가 후 큐에 추가
3. 방문 배열을 순회하면서 익지 않은 토마토가 있는 경우 `fail` 플래그를 `true`로 변경
4. `fail` 플래그가 `true`인 경우 `-1` 출력, 아닌 경우 방문 배열의 최댓값 출력

### C++

```c++ title="C++"
#include <bits/stdc++.h>
using namespace std;

const int dy[] = {-1, 0, 1, 0};
const int dx[] = {0, 1, 0, -1};

int m, n, a[1004][1004], vis[1004][1004], ret;
bool fail = false;
queue<pair<int, int>> q;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);

  cin >> m >> n;

  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      cin >> a[i][j];

      if (a[i][j] == 1) {
        q.push({i, j});
      }

      if (a[i][j] == 0) {
        vis[i][j] = -1;
      }
    }
  }

  while (q.size()) {
    int y, x;
    tie(y, x) = q.front();
    q.pop();

    for (int i = 0; i < 4; i++) {
      int ny = y + dy[i];
      int nx = x + dx[i];

      if (ny < 0 || nx < 0 || ny >= n || nx >= m) continue;
      if (a[ny][nx] == -1 || vis[ny][nx] >= 0) continue;
      vis[ny][nx] = vis[y][x] + 1;
      q.push({ny, nx});
    }
  }

  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (vis[i][j] == -1) {
        fail = true;
      }
      ret = max(ret, vis[i][j]);
    }
  }

  if (fail)
    cout << -1;
  else
    cout << ret;

  return 0;
}
```

### JavaScript

```js title="JavaScript" hl={18, 31-32}
const fs = require('fs');
const filePath = process.platform === 'linux' ? '/dev/stdin' : '../input.txt';
const input = fs.readFileSync(filePath).toString().trim().split('\n');

const [m, n] = input
  .shift()
  .split(' ')
  .map((v) => +v);

const dy = [-1, 0, 1, 0];
const dx = [0, 1, 0, -1];

const a = input.map((v) => v.split(' ').map((v) => +v));
const vis = [...Array(n)].map((v) => Array(m).fill(0));

const solution = (m, n, a) => {
  const q = [];
  let idx = 0;

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (a[i][j] === 1) {
        q.push([i, j]);
      }
      if (a[i][j] === 0) {
        vis[i][j] = -1;
      }
    }
  }

  while (q.length > idx) {
    const [y, x] = q[idx++];

    for (let i = 0; i < 4; i++) {
      const ny = y + dy[i];
      const nx = x + dx[i];

      if (ny < 0 || nx < 0 || ny >= n || nx >= m) continue;
      if (a[ny][nx] === -1 || vis[ny][nx] >= 0) continue;
      vis[ny][nx] = vis[y][x] + 1;
      q.push([ny, nx]);
    }
  }

  let max = 0;

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (vis[i][j] === -1) {
        return -1;
      }
      max = Math.max(max, vis[i][j]);
    }
  }

  return max;
};

console.log(solution(m, n, a));
```
