---
title: 프로그래머의 뇌
description:
thumbnail:
tags: ['Productivity']
createdAt: 2025-09-13T19:11:09.396Z
---

## 책 소개

이 책에서는 코드를 읽고 이해하는 과정에서 초반에 등장하는 장기 기억, 단기 기억, 작업 기억 공간에 대한 상호작용 뿐만 아니라 다양한 요소에 대해서 많은 연구 사례와 함께 분석하여 설명합니다.
프로그래머라면 누구나 한번쯤 궁금했을 "내 뇌는 코딩할 때 어떻게 작동하는가?"라는 질문에 대한 과학적이고 실용적인 답을 제시하는 책이라고 생각합니다.

## 기억 하고 싶은 부분

### 머리말

<Blockquote type="info">

**우리가 무슨 일을 할 때 가장 중요한 것은 마음가짐이나 심리다.** 처음 접하는 내용이기에 이해가 어려운 것은 당연하다. 이게 마치 자신의 머리가 나빠서 이해를 하지 못한다고 생각하고 스스로 위축되기 시작하면 프로그래밍을 배우는 과정은 더욱 험난할 것 이고 중도에 포기할 가능성도 높다.

</Blockquote>

### 코드 더 잘 읽기

<Blockquote type="info">

**실제 사고 작용은 LTM이나 STM이 아닌 작업 기억 공간에서 일어난다.** 생각, 아이디어 해결책 같은 것들이 여기에서 만들어진다. LTM은 하드 드라이브, STM은 메인 메모리로 생각한다면, 작업 기억 공간은 두뇌의 프로세서라고 볼 수 있다.

**- 10p -**

</Blockquote>

<Blockquote type="info">

왜 이 코드는 기억하기 어려웠을까? **가장 결정적인 이유는 STM의 용량에 제한이 있기 때문이다.** …
STM은 읽거나 들은 정보를 짧은 시간만 저장한다. 여기서 짧은 시간이라는 것은 정말로 짧은 시간을 의미하는데 연구에 의하면 **30초를 넘지 않는다.** …
STM은 정보를 저장하는 시간뿐만 아니라 크기 또한 제약된다.

**- 19p -**

</Blockquote>

<Blockquote type="info">

특정한 주제에 대해 두뇌가 더 많은 정보를 저장하고 있다면 입력된 **정보들을 효율적으로 청크로 묶는 것이 수월해진다는 사실을 살펴봤다.** …
LTM에 지식이 많으면 기억을 쉽게 한다는 사실은 프로그래밍에도 해당한다.

**- 23p -**

</Blockquote>

<Blockquote type="info">

기억을 강화하는 두 가지 테크닉에 대해서 다룰텐데 적극적으로 무언가를 일부러 기억해보려고 애쓰는 **인출(retrieval) 연습과 기존 기억에 새로운 지식을 적극적으로 연결시키는 정교화(elaboration)다.**

**- 44p -**

</Blockquote>

<Blockquote type="info">

저장 강도는 감소하지 않고 늘어나는 반면 **인출 강도는 시간이 흐를수록 약해지는 것으로 알려져 있다.** 기억은 결코 소실되지 않는다는 최근의 연구 결과도 있다. 어떤 정보를 반복해서 학습할 때 그 내용의 저장 강도는 강화된다. **자기가 이미 알고 있다고 생각하는 내용을 기억하려고 노력하면 추가 학습 없이도 인출 강도가 강화된다.**

**- 45p -**

</Blockquote>

<Blockquote type="info">
**너무 쉽게 정보를 찾고 또 그것이 너무 일상적으로 이뤄지다 보니 우리 두뇌는 문법을 기억할 필요가 없다고 느낀다.** 따라서 프로그래밍 문법에 대한 인출 강도가 강화되지 않고 계속 약한 상태로 남아 있게 된다. …
**따라서 다음번에 구글에서 프로그래밍 문법에 대해 검색하려고 할 때, 검색 이전에 먼저 그것을 능동적이고 의도적으로 기억하려고 시도해보기 바란다.** …

기억을 강화하는 두 번째 방법이 있는데 그것은 정보에 대해 능동적으로 생각하고 그것을 반추해보는 것이다. 정보에 대해 생각하는 과정을 정교화(relaboration)라고 부른다. …

**새로운 정보를 학습할 때 정보는 LTM에 저장하기 전에 먼저 스키마의 형태로 만들어진다. 이미 존재하는 스키마에 잘 맞는 정보일 수록 더 쉽게 기억할 수 있다.**

**- 47p -**

</Blockquote>

<Blockquote type="info">
정교화는 기억하고자 하는 내용을 **기존 기억과 연관 지으면서 생각하는 것**을 뜻하고, 이렇게 한 결과 LTM에 이미 저장되어 있는 스키마타에 맞춰서 새로운 기억이 저장된다.

**- 49p -**

</Blockquote>

<Blockquote type="info">
대개의 경우 리팩터링은 코드의 유지 보수를 쉽게 하기 위한 목적으로 이루어진다. …

**하지만 코드가 전체적으로 유지 보수하기 좋게 수정됐다고 해서 가독성까지 반드시 좋아지는 것은 아니다.** …
따라서 유지 보수하기 좋은 코드를 작성하기보다는 **장기적으로 가독성이 높은 코드를 작성하도록 리팩터링하는 것이 좋을 수 있다.** …

이런 방식의 리팩터링을 인지적 리팩터링(cognitive refactoring)이라고 정의한다 … 인지적 리팩터링의 목표는 코드를 유지 보수하기 좋은 코드로 변경하는 것이 아니라 현 시점에서 개발자가 읽기 쉬운 코드로 변경하는 것이다. 인지적 리팩터링은 떄로는 역 리팩터링(reverse refactoring)을 수반할 수 있다.

**- 56p -**

</Blockquote>

<Blockquote type="info">
복잡한 구조의 코드는 두 가지 방식으로 작업 기억 공간에 과부하를 유발한다.  첫 번째로, 정확히 코드의 어디를 파악해야 하는지 모를 때이다. … 두 번째로 코드가 서로 밀접하게 연결되어 있는 경우 두뇌는 두 가지 작업을 동시에 수행한다.

**- 61p -**

</Blockquote>

### 코드에 대해 생각하기

<Blockquote type="info">
**코드에 대해 추론할 때는 변수가 중심적인 역할을 한다.** 변수가 어떤 종류의 정보를 담고 있는지 이해하는 것은 코드를 추론하고 수정하는 데 결정적인 역할을 한다. … 사야니에미 교수는 다음과 같은 11개의 역할로 대부분의 변수를 설명할 수 있다고 주장한다.

- 고정값(fixed value)
- 스테퍼(stepper)
- 플래그(flag)
- 워커(worker)
- 최근값 보유자(most recent holder)
- 목적값 보유자(most wanted holder)
- 모집자(gatherer)
- 컨테이너(container)
- 추적자(follower)
- 조직자(organizer)
- 임시(temporary)

**- 72p -**

</Blockquote>

<Blockquote type="info">
코드를 읽을 때 초점은 중요한 개념이다. 간단히 말하자면, **어디서부터 읽기 시작해야 할지 알아야한다는 것이다.**

**- 82p -**

</Blockquote>

<Blockquote type="info">

무언가를 알고 있어 새로운 것을 배우거나 새로운 작업을 할 때 도움이 되는 전이를 긍정적 전이(positive transfer)라고 부른다. … **전이가 항상 긍정적인 결과만 갖는 것은 아니다. 기존 지식이 새로운 것을 배우는 데 방해가 될 때, 이것을 부정적 전이(negative transfer)라고 부른다.**

네덜란드의 컴퓨터 과학 교수 이자 다익스트라 알고리즘을 고안한 에츠허르 다익스트라는 “정신이 손상되기” 때문에 베이직을 가르치는 것은 금지되어야 한다는 유명한 말을 했다.

**- 124p -**

</Blockquote>

<Blockquote type="info">
여기서 중요한 점은 하나의 프로그래밍 언어를 숙달했다는 사실이 새로운 언어를 배우는 데 항상 도움이 되는 것은 아니라는 것이다. …
이와 관련하여 고려해야 할 조언은 **사고방식을 확장하기 위해 새로운 언어를 배우기 시작했다면 이미 습득한 언어와는 근본적으로 다른 언어를 선택하는 것이 중요하다는 것이다.**

**- 126p -**

</Blockquote>

<Blockquote type="info">
오개념은 강한 확신 속에 있는 잘못된 사고 방식이다. …
이미 알고 있는 프로그래밍 언어 떄문에 생긴 오개념을 현재 학습 중인 새로운 언어에 맞는 정신 모델로 대체하는 과정을 개념 변화(conceptual change)라고 한다. …

이미 학습한 지식을 LTM에서 변경해야 하기 때문에 개념 변화 학습은 일반적인 학습보다 더 어렵다. 이 점 때문에 오개념이 쉽게 사라지지 않고 오랫동안 지속된다. …
**따라서 새로운 프로그래밍 언어를 배울 때는 이전 프로그래밍 언어에 대한 기존의 지식을 떨쳐내기 위해 많은 에너지를 소비해야한다.**

**- 128p -**

</Blockquote>

### 좋은 코드 작성하기

<Blockquote type="info">
넷스케이프의 프로그래머 필 칼튼은 **컴퓨터 과학에는 난제가 딱 두가지 있는데, 바로 캐시 무효화와 이름 짓기라는 유명한 말을 했다.** …
이름 짓는 일은 어렵지만, **코드에서 우리가 추론하는 객체에 맞는 이름을 고르는 것은 중요하다.**

**- 138p -**

</Blockquote>

<Blockquote type="info">
변수 이름의 형식을 지정하는 방법에 대한 명확한 규칙을 가지고 있으면 STM이 코드에 있는 이름을 이해하는 데 도움이 될 수 있다.

**- 144p -**

</Blockquote>

<Blockquote type="info">
유사한 이름 틀을 사용하면 작업 기억 공간과 LTM에 큰 도움이 되기 때문에 각 코드베이스에서 사용할 수 있는 여러 가지 이름 틀을 미리 정해놓는 것이 좋다. **프로젝트를 시작할 때 이름 틀에 대해 협의하는 것은 이러한 방향으로 가는 좋은 단계일 것이다.**

**- 156p -**

</Blockquote>

<Blockquote type="info">
비슷한 이름 틀을 사용하는 것은 코드를 이해하는데 도움이 되지만 프로그래머들은 종종 동일한 객체에 대해 다양한 이름 틀을 사용한다는 것을 살펴봤다. 이러한 사실을 바탕으로 페이텔슨은 **개발자들이 더 나은 이름을 선택하는 데 도움이 되도록 3단계 모델**을 설계했다.

1. 이름에 포함할 개념을 선택한다.
2. 각 개념을 나타낼 단어를 선택한다.
3. 이 단어들을 사용하여 이름을 구성한다.

**- 157p -**

   </Blockquote>

<Blockquote type="info">
코드가 혼란을 초래하는 이유를 살펴보기 위해 우리가 사용할 첫 번째 프레임워크는 코드 스멜이라는 개념이다.  **코드 스멜은 작동은 하지만 개선의 여지가 있는 코드를 의미한다.** … 파울러는 다양한 코드 스멜과 함꼐 이것을 해소하기 위한 전략을 함께 목록화해서 설명했고, 이 과정을 리팩터링이라고 불렀다.

**- 160p -**

</Blockquote>

<Blockquote type="info">
코드 스멜은 구조적 안티패넡 문제가 있는 코드다. **이것은 코드가 잘 작성되었으나 파악하기 어려운 구조로 만들어졌다는 것을 의미한다.**

그러나 코드에서 ‘개념적’ 안티패턴도 있을 수 있다. 코드가 짦은 메서드와 깔끔한 클래스로 올바르게 구성되어 있지만 **혼동되는 이름을 갖는 경우다.** 이러한 코드 문제는 두 번째 프레임워크인 언어적 안티패턴으로 설명할 수 있다. 두 프레임워크는 코드의 서로 다른 측면을 다루기 떄문에 서로 잘 보완한다. …

아나우도바는 언어적 안티패턴을 코드의 언어적 요소와 그 역할 사이의 불일치로 묘사한다. 코드의 언어적 요소란 메서드 입출력 정의, 설명 문서, 속성 이름, 데이터 타입, 주석문 등을 포함하는 코드의 자연어 부분을 정의한다.

**- 166p -**

</Blockquote>

<Blockquote type="info">

문제 해결 능력을 높이는 두 가지 방법에 대해 알아보겠다. **첫 번째 기술은 자동화다.**

**- 180p -**

</Blockquote>

<Blockquote type="info">

프로그래밍에 대한 암시적 기억이 많을수록 인지 부하를 더 많이 절약할 수 있기 때문에 더 큰 문제를 해결하기가 쉽다. …
**암시적 기억은 다른 방식, 즉 반복에 의해 생성된다.** …

어떻게 해야하는지에 대한 기억은 생각을 해서 얻어지는 것이 아니라 **연습을 통해 만들어진다.** 그래서 암시적 기억이라고 부르는 것이다.

암시적 기억은 세 가지 단계로 형성된다. 첫 번째 단계인 인지 단계는 무언가 새로운 것을 배우는 때다. 이 단계에서는 새로운 정보를 더 작은 부분으로 나누고 당면한 작업에 대해 명시적으로 생각한다. …
다음 단계는 연상 단계다. 이 단계에서는 응답 패턴이 나타날 때 까지 새 정보를 적극적으로 반복해야 한다. …
마지막으로, 기술이 완벽한 자율 단계에 도달한다. …
자율 단계에 도달하면 기술을 자동화했다고 볼 수 있다. **아무런 노력 없이 그 일을 수행할 수 있고, 그 기술을 쓴다고 해서 인지 부하가 증가하지도 않는다.**

**- 182p -**

</Blockquote>

<Blockquote type="info">
문제 해결 능력을 향상하기 위해 사용할 수 있는 **두 번째 방법은 다른 사람들이 문제를 어떻게 해결했는지 의도적으로 연구하는 것이다.**

**- 186p -**

</Blockquote>

### 코딩에서의 협업

<Blockquote type="info">
팀의 선임자들은 효과적으로 가르치고 설명하는 데 어려움을 겪는 이유 중 하나는 많은 경우 **‘전문가의 저주’** 때문이다. **어떤 기술을 충분히 익히고 나면, 그 기술이나 지식을 배우는 것이 얼마나 어려웠는지 잊어버린다.** 따라서 새 팀원이 동시에 처리할 수 있는 새로운 작업의 수를 과대평가하게 된다.

**- 223p -**

</Blockquote>

## 후기

이 책에서 제게 흥미로웠던 부분은 크게 3가지 정도가 있었던 것 같습니다.

**첫 번째는 장기 기억(LTM), 단기 기억(STM) 그리고 작업 기억 공간으로 구성된 구조와 이들의 상호작용이었습니다.**
프로젝트 진행 중에 종종 의존하고 있는 오픈소스 라이브러리 로직을 살펴볼 때면 원하는 수준까지 이해하기 위해서 꽤 많은 시간을 사용했던 경험이 있었습니다.
이를 개선하기 위해서는 막연하게 코드를 많이 봐야겠다는 생각만 했었는데 이 부분을 보고 좀 더 전략적으로 접근해야겠다고 생각했습니다.
예를 들면, LTM에 관련 지식을 더 쌓고 STM의 토큰을 효율적으로 사용하기 위해서 먼저 전반적인 코드 구조를 살펴보고 디자인 패턴에 대한 학습을 하면 좋겠다는 생각이 들었습니다.

**두 번째는 기억을 강화하는 두가지 테크닉인 인출 연습과 정교화입니다.**
요즘에는 정보의 양은 넘치고 변화 또한 빠르면서 특정한 정보를 찾기 매우 쉽기 때문에 어떤 정보를 기억해야하는 필요성이 처참할 정도로 줄어든 것 같습니다.
하지만 사회 속에서 업무라는 것은 사람들과 논의하고 설득하는 것이 필수적인데 이를 뒷받침해주는 중요한 정보를 기억하는 것은 여전히 중요하고 결과에 큰 영향을 미칠 수 있다고 생각합니다.
이를 대비해서라도 적극적으로 무언가를 일부러 기억해보려는 인출 연습과 기존 기억에 새로운 지식을 적극적으로 연결시키는 정교화 연습을 하면 좋겠다는 생각이 들었습니다.

**세 번째는 문제 해결 능력을 높이는 두 가지 방법인 자동화와 다른 사람의 문제 해결 방법 의도적 연구하기입니다.**
분야를 불문하고 학습에 있어서 반복을 통한 자동화와 좋은 피드백을 받아들이는 의도적 연구하기는 핵심이라고 생각합니다. 이 책을 계기로 좀 더 적극적으로 이를 실천해보려고 합니다.

다양하고 깊은 연구 사례와 함께 설명하는 부분이 많아서 다소 지루했던 적도 있었지만 프로그래머로서 코드와 인지과학에 대해 좋은 인사이트와 도구를 얻었다고 생각합니다. : )
