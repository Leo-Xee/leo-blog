---
title: 클래스 내부 구조
description: ES6에서 클래스가 도입되기 전까지 사용된 방식인 프로토타입으로 클래스를 구현하는 방법과 원리를 정리합니다.
thumbnail:
tags: ['JavaScript']
createdAt: 2023-08-30T12:41:21.239Z
---

## TL;DR

<Blockquote type="info">

- **ES5에서 클래스 구현**: 자바스크립트는 ES6 이전에 클래스를 직접적으로 지원하지 않았으며, 대신 프로토타입 기반으로 클래스를 구현했습니다. ES5에서는 함수에 new 연산자를 사용해 인스턴스를 생성하고, 생성된 인스턴스가 함수의 prototype에 접근하는 방식으로 클래스를 구현했습니다.
- **ES5에서 클래스 상속 구현**: ES5에서는 하위 클래스가 상위 클래스를 상속받도록 하기 위해, 하위 클래스의 prototype을 상위 클래스의 인스턴스로 설정하고, constructor를 복구하는 등의 작업이 필요했습니다. 중복 코드를 줄이기 위해 빈 객체를 중간 다리로 사용하는 패턴을 사용하여 상속 구조를 효율적으로 구현했습니다.
- **클래스 상속을 함수로 추상화**: 상속을 간편하게 구현하기 위해, 즉시 실행 함수(IIFE)를 활용하여 상속을 처리했습니다. 이를 통해 중복 코드와 메모리 낭비를 방지하고, 클래스 상속을 쉽게 구현할 수 있었습니다.

</Blockquote>

## ES5의 클래스

대부분의 객체지향 프로그래밍 언어와는 달리, 자바스크립트는 초기 설계 시 클래스와 클래스 상속을 지원하지 않았습니다. 이 때문에 객체지향 프로그래밍에 익숙했던 개발자들은 다양한 클래스 관련 라이브러리를 만들어 사용했습니다. 이러한 배경으로 인해, ES6에서는 Class 문법이 포함되게 되었습니다.

하지만, 자바스크립트의 본질인 프로토타입 기반의 설계는 바뀌지 않았습니다. 내부적으로는 여전히 프로토타입을 통해 클래스를 구현하고 있기 때문입니다. 이로 인해 Class 문법은 단순히 문법 설탕(Syntax Sugar)에 지나지 않는다고도 할 수 있습니다. 따라서 ES5의 프로토타입으로 구현된 클래스를 이해하는 것은 ES6의 클래스 문법의 내부 원리를 이해하는 데 도움이 될 수 있습니다.

## ES5의 클래스 구조

먼저 Array 생성자 함수를 예로 들어보겠습니다.

![그림1. Array 생성자 함수](/assets/contents/js-es5-class/1.png)

Array 생성자 함수는 자신만이 접근할 수 있는 `static method`, `static property`, 그리고 `prototype`을 가집니다. `prototype`은 `new` 연산자로 만들어진 인스턴스도 접근 가능한 메서드를 포함합니다.

![그림2. 인스턴스의 접근 여부](/assets/contents/js-es5-class/2.png)

`new` 연산자로 생성된 인스턴스들의 접근을 더 구체적으로 도식화하면 위와 같습니다.

인스턴스는 static한 것들에 접근할 수 없고, `prototype`의 메서드에만 접근할 수 있습니다. 그 이유는 인스턴스의 `__proto__`가 생성자 함수가 아닌, 생성자 함수의 `prototype`을 참조하고 있기 때문입니다.

### 예시

이해하기 어렵다면 예시를 통해 알아보겠습니다.

![그림3. 인스턴스의 접근 여부의 예시](/assets/contents/js-es5-class/3.png)

생성자 함수 Vehicle을 만들고 `prototype`에 메서드를 추가합니다. 자바스크립트에서는 함수도 객체이기 때문에, 함수인 Vehicle에 `new` 연산자를 사용하여 인스턴스를 생성할 수 있고, 이를 `v1`에 할당할 수 있습니다. 그러면 `v1`은 Vehicle의 `prototype`의 메서드를 사용할 수 있는 하나의 인스턴스로서 역할을 할 수 있습니다.

**정리하자면, ES5에서는 `new` 연산자를 함수에 사용할 수 있다는 점과, 생성된 인스턴스가 `__proto__`를 통해 생성자 역할을 하는 함수의 `prototype`에 접근할 수 있다는 자바스크립트의 특성 덕분에 클래스를 구현할 수 있습니다.**

## ES5의 클래스 상속

지금까지 하나의 클래스를 생성하는 방법을 알아보았습니다. 이제 객체지향 프로그래밍의 중요한 특징 중 하나인 상속을 어떻게 구현할 수 있는지 알아보겠습니다.

다음은 중복되는 개념과 메서드를 가진 두 개의 클래스입니다. 이 클래스들에서 중복을 제거하고 효율적으로 구현하려면 어떻게 해야 할까요?

![그림4. ES5의 클래스 상속1](/assets/contents/js-es5-class/4.png)

클래스의 상속을 구현하는 방법은 `prototype`을 다음과 같은 구조로 만드는 것입니다.

![그림5. ES5의 클래스 상속2](/assets/contents/js-es5-class/5.png)

이 구조를 구현하기 위해서는 다음과 같은 작업이 필요합니다.

- 1번과 같이 하위 클래스의 `prototype`을 상위 클래스의 인스턴스로 지정합니다.
- 1번 작업으로 인해 `prototype`의 `constructor`가 없어졌기 때문에, 2번과 같이 이를 복구합니다.
- 마지막으로 `Vehicle`의 `prototype`에는 `getBattery()` 메서드가 없기 때문에, 3번과 같이 추가해줍니다.

### 예시와 문제 발견

전체 소스 코드로 옮기면 다음과 같습니다.

![그림6. ES5의 클래스 상속의 문제](/assets/contents/js-es5-class/6.png)

위와 같이 완성된 것처럼 보이지만, 여기서 한 가지 문제점을 발견할 수 있습니다.

앞서 `Vehicle`의 `constructor`를 `ElectricVehicle`로 변경하는 바람에 `Vehicle`의 `property`가 빈 값으로 할당되어 버립니다. 이로 인해 만약 `ElectricVehicle`의 `name`이나 `price` `property`가 제거된다면, 프로토타입 체인으로 인해 빈 값에 접근하여 개발자가 예상하지 못한 동작이 발생할 수 있습니다.

### 문제 해결

**위의 문제를 해결하기 위해 [Douglas Crockford](https://ko.wikipedia.org/wiki/%EB%8D%94%EA%B8%80%EB%9D%BC%EC%8A%A4_%ED%81%AC%EB%A1%9D%ED%8F%AC%EB%93%9C)가 고안한 해결책은 빈 객체를 생성해 중간 다리로 사용하는 방법입니다.** 이 방법은 다음과 같습니다.

![그림7. ES5의 클래스 상속의 문제 해결 1](/assets/contents/js-es5-class/7.png)

![그림8. ES5의 클래스 상속의 문제 해결 2](/assets/contents/js-es5-class/8.png)

**이렇게 빈 객체를 중간 연결 다리로 사용하면 `Vehicle`의 `property`로 인해 발생할 수 있는 문제를 방지할 수 있습니다.** 하지만 매번 이 작업을 구현하기는 번거롭고 비효율적이기 때문에, 다음과 같이 함수화하여 사용합니다.

### 함수화

```js
let extendClass = (function () {
  function Bridge() {}
  return function (Parent, Child) {
    // 클로저
    Bridge.prototype = Parent.prototype;
    Child.prototype = new Bridge();
    Child.prototype.construtor = Child;
  };
})(); // 즉시 실행 함수(IIFE)
```

**즉시 실행 함수(IIFE)로 `Bridge 함수`를 클로저로 반환해주고 있기 때문에 전역 실행 컨텍스트에서 계속 접근할 수 있도록 남아 있게되고 중복으로 인해 메모리 낭비가 될 여지도 없습니다.**

### 함수 적용

최종적으로 위의 함수를 사용해서 클래스 상속을 구현한 코드는 다음과 같습니다.

```js
let extendClass = (function () {
  function Bridge() {}
  return function (Parent, Child) {
    Bridge.prototype = Parent.prototype;
    Child.prototype = new Bridge();
    Child.prototype.construtor = Child;
  };
})();
extendClass(Vehicle, ElectricVehicle);
ElectricVehicle.prototype.getBattery = function () {
  return this.battery;
};
```

## 참조

- https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-javascript-flow/
- https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/
