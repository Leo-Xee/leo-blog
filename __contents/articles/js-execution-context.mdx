---
title: 실행 컨텍스트
description: 자바스크립트의 실행 컨텍스트에 대해서 알아봅니다.
thumbnail:
tags: ['JavaScript']
createdAt: 2023-05-23T13:42:01.872Z
---

## TL;DR

<Blockquote type="info">

- **실행 컨텍스트**: 자바스크립트는 실행 컨텍스트를 통해 코드가 실행되는 환경을 정의하며, 함수가 실행될 때마다 새로운 실행 컨텍스트가 생성됩니다. 블록 스코프에서는 별도의 실행 컨텍스트가 생성되지 않으며, 실행 컨텍스트는 오직 함수에 의해서만 구분됩니다.
- **콜 스택과 실행 컨텍스트 내부**: 함수가 실행되는 순서는 콜 스택에 의해 관리되며, 실행 컨텍스트는 VariableEnvironment, LexicalEnvironment, thisBinding 세 가지로 구성됩니다.
- **호이스팅과 스코프 체인**: 호이스팅은 변수나 함수의 선언 부분이 LexicalEnvironment에서 미리 수집되어 발생하는 현상입니다. 스코프 체인은 LexicalEnvironment의 outerEnvironmentReference를 통해 외부 환경의 식별자를 참조하며, 내부에서 외부로만 참조가 가능해 전역에서 내부 변수에 접근할 수 없습니다.

</Blockquote>

## 실행 컨텍스트

**실행 컨텍스트(Execution Context)는 코드가 실행되기 위해 필요한 환경을 의미합니다.** 이 개념은 스코프 체인(Scope Chain), 호이스팅(Hoisting), this, 클로저(Closure) 등의 동작을 설명할 수 있는 자바스크립트의 핵심 원리입니다.

자바스크립트는 함수 단위로 실행 컨텍스트를 구분합니다. 즉, 새로운 함수가 실행될 때마다 새로운 실행 컨텍스트가 생성되며, 동일한 함수 스코프 내에서 작성된 코드는 동일한 환경에서 실행된다고 이해할 수 있습니다.

그렇다면, `if문`, `for문`, `switch문`, `while문`과 같은 블록 스코프에도 동일하게 적용되는 것일까요? 그렇지는 않습니다. ES6에서 블록 스코프 개념이 도입되면서 `let`과 `const`에 한해서만 블록 스코프라는 별도의 공간이 생성되지만, 별도의 실행 컨텍스트는 생성되지 않습니다.

정리하자면, 자바스크립트는 오직 함수에 의해서만 실행 컨텍스트를 구분합니다.

## 콜 스택

**함수가 실행되는 순서를 제어하기 위해 스택 자료구조를 사용하는데, 이를 콜 스택(Call Stack)이라고 부릅니다.** 아래 그림과 같이 `전역 함수` - `outer 함수` - `inner 함수` 순으로 각각의 실행 컨텍스트가 콜 스택에 쌓입니다.

![그림1. 콜 스택](/assets/contents/js-execution-context/1.png)

## 실행 컨텍스트의 내부

콜 스택에 쌓인 실행 컨텍스트의 내부를 자세히 살펴보면, 실행 컨텍스트는 3가지의 환경 정보를 담고 있습니다.

![그림2. 실행 컨텍스트의 내부 구조](/assets/contents/js-execution-context/2.png)

- **`VariableEnvironment`**: 최초 식별자들을 스냅샷으로 저장하고 변화 없이 유지합니다.

  - **`environmentRecord`**: 현재 환경의 최초 식별자들을 스냅샷으로 저장하고 유지합니다.
  - **`outerEnvironmentReference`**: 외부 환경의 최초 식별자들을 참조해 스냅샷으로 저장하고 유지합니다.

- **`LexicalEnvironment`**: 함수 내의 식별자들을 저장하고 변화가 생기면 실시간으로 반영합니다.

  - **`environmentRecord`**: 현재 환경의 식별자들을 저장하고 변화가 생기면 실시간으로 반영합니다.
  - **`outerEnvironmentRecord`**: 외부 환경의 식별자들을 저장하고 변화가 생기면 실시간으로 반영합니다.

- **`thisBinding`**: `this`에 관련된 정보는 추후에 정리할 예정입니다.

이 구조를 이해한 후, `VariableEnvironment`는 백업을 위한 것이라고 생각하고, 값이 실시간으로 변하는 `LexicalEnvironment`에 집중하는 것이 중요합니다.

## 호이스팅

![그림3. 호이스팅의 과정](/assets/contents/js-execution-context/3.png)

`LexicalEnvironment`의 `environmentRecord`는 현재 환경의 식별 정보를 수집합니다. 다시 말해, 현재 환경 내의 코드를 실행하기 전에 변수의 선언이나 함수 선언을 미리 수집하는 것입니다. 여기서 주의할 점은 할당이 아닌 선언 부분만을 미리 수집한다는 것입니다. 이 특징 때문에, 선언 부분이 상단으로 끌어올려진 것처럼 느껴지는 현상을 호이스팅(Hoisting)이라고 합니다.

호이스팅은 단순히 선언들이 상단으로 이동한 후 동작하는 것이 아니라, `environmentRecord`가 먼저 식별 정보를 수집하고, 이 정보를 기반으로 코드를 실행하기 때문에 발생하는 현상입니다.

## 스코프 체인

![그림4. 스코프 체인의 원리](/assets/contents/js-execution-context/4.png)

**`LexicalEnvironment`의 `outerEnvironmentReference`는 외부 환경의 식별자 정보를 참조합니다. 이러한 참조가 위의 그림처럼 연쇄적으로 일어나면서 발생하는 현상을 스코프 체인(Scope Chain)이라고 합니다.** 이 참조는 내부에서 외부로만 이루어지기 때문에, 외부에서는 내부의 식별자 정보를 알 수 있는 방법이 없습니다. 전역 공간에서 내부 함수 내의 변수에 접근할 수 없는 이유도 이와 동일합니다.

## 참조

- https://bit.ly/3L1uo8d
