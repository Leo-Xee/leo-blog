---
title: 문자셋과 인코딩
description: 문자셋과 인코딩의 개념과 종류에 대해서 알아봅니다.
thumbnail:
tags: ['Computer Science']
createdAt: 2023-12-30T08:12:31.118Z
---

## TL;DR

<Blockquote type="info">

- **문자셋과 인코딩 개념**: 문자셋은 언어를 표현하기 위한 문자들의 집합으로, SBCS는 1바이트, MBCS는 가변 바이트, WBCS는 2바이트를 사용합니다. 인코딩은 이러한 문자셋을 컴퓨터가 이해할 수 있도록 바이트로 변환하는 규칙을 의미합니다.
- **문자 인코딩 방식**:
  - ASCII는 7비트로 구성되어 128개의 문자를 지원합니다.
  - ANSI는 8비트로 256개의 문자를 지원하며, 각 언어에 대한 CodePage를 사용합니다.
  - EUC-KR과 CP949는 한국어 지원을 위해 확장된 문자셋입니다.
  - 유니코드는 모든 문자를 포함할 수 있도록 설계된 문자셋으로, 2바이트로 시작해 보충 평면을 통해 약 111만 개의 문자를 지원합니다.
- **UTF 인코딩 방식**:
  - UTF-8은 가변 길이 인코딩으로, 영어는 1바이트, 유럽 언어는 2바이트, 동아시아 언어는 3바이트 이상을 사용합니다.
  - UTF-16은 16비트 기반으로 2바이트로 저장하지만, 때로는 4바이트가 필요합니다.
  - UTF-32는 모든 문자를 4바이트로 인코딩하지만, 메모리 사용이 비효율적입니다.

</Blockquote>

## 문자셋

하나의 언어권에서 사용하는 언어를 표현하기 위한 모든 문자들의 집합을 문자셋(Charactor Set)이라고 합니다. 문자셋은 byte의 길이에 따라 다음과 같이 분류합니다.

- SBCS(Single Byte Charactor Set)는 문자 표현에 있어서 1byte만 사용하는 방식입니다. (예: ASCII)
- MBCS(Multi Byte Charactor Set)는 문자 표현에 있어서 문자마다 가변적인 byte의 길이를 사용하는 방식입니다.
- WBCS(Wide Byte Charactor Set)는 모든 문자 표현을 2bytes만 사용하는 방식입니다. (예: Unicode)

## 인코딩

**인코딩(Encoding)은 정의된 문자셋을 컴퓨터가 이해할 수 있도록 byte와 맵핑하는 과정이자 규칙입니다.**
예를 들자면, ASCII 코드 문자 'A'의 코드 65를 컴퓨터가 이해할 수 있도록 byte code로 변환해주는 것을 말합니다.

## ASCII

**ASCII(American Standard Code for Information Interchange)는 미국에서 오직 영어만을 고려해서 정의한 표준화된 통신부호체계이자 최초의 문자열 인코딩입니다.** 이는 7bits로 구성되어 있으며, 영어를 위한 문자와 숫자, 특수문자, 기호, 제어문자 등 128개의 문자를 표현할 수 있습니다.

다음의 표를 보면 0 ~ 32까지는 인쇄와 전송 제어에 사용되는 용어, 33 ~ 127까지는 알파벳 대소문자와 숫자 그리고 특수문자들로 이루어진 것을 볼 수 있습니다.

![그림1. ASCII CODE 표](/assets/contents/charset-encoding/1.png)

## ANSI

**ANSI(American National Standard Institute)는 ASCII 에서 한 비트를 확장한 8bits로 구성되고 256개의 문자를 표현할 수 있습니다.** 이는 영어 외의 다른 언어들을 표현하기 위해 확장된 개념이지만, 고작 추가된 128개의 문자로는 모든 언어의 문자를 표현할 수 없었습니다. 그래서 생겨난 개념이 CodePage입니다. 이는 각 언어별로 Code값을 주고 Code마다 다른 문자열 표를 배정하도록 했습니다.

**ANSI = ASCII(7bits) + CodePage(1bit)로 구성됩니다.**

그러나 ANSI도 한국, 일본, 중국과 같은 비유럽 국가들의 문자를 표현하기에는 부족했고, 각 언어마다 CodePage가 따로 배정되어서 언어들을 혼합하여 사용할 수 없었습니다. 그래서 등장한 것이 마지막에 설명할 유니코드(Unicode)입니다.

## EUC-KR

**EUC-KR(Extended Unix Code-Korea)은 한글 지원을 위해 유닉스 계열에서 나온 완성형 코드 조합입니다.**

완성형 코드란 완성된 문자 하나하나마다 코드 번호를 부여한 것이며, 이와 반대되는 개념인 조합형 코드는 한글의 자음과 모음 각각에 코드 번호를 부여한 후 초성, 중성, 종성을 조합하여 하나의 문자를 나타내는 방식을 말합니다.
EUC-KR은 ANSI를 한국에서 확장한 것으로, 한국을 제외한 대부분 나라에서 지원이 불가합니다.

## CP949

**CP949(Code Page 949)는 한글 지원을 위해 윈도우즈 계열에서 나온 완성형 코드 조합이며 마이크로소프트에서 만들었다고 해서 MS949라고도 부릅니다.**

EUC-KR은 2bytes의 완성형 코드로 2bytes 내에서는 표현할 수 있는 완성된 문자의 수가 한계가 있었습니다.
그래서 마이크로소프트에서 이를 확장하여 만든 것이 CP949입니다. 여기서 949는 페이지 번호를 의미하며, 한국을 의미하고 언어마다 고유의 번호가 붙습니다.

## 유니코드

**유니코드(Unicode)는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현할 수 있도록 고안된 코드 조합입니다.** 유니코드는 이전에 비해 용량을 크게 확장한 `2byte(2^16 = 65,536)`를 사용하였으며, 유니코드 3.0까지는 이 2byte 영역을 다국어 기본 평면(BMP, Basic Multilingual Plane)라고 불렀습니다.

처음에는 65,536개의 문자로 모든 언어를 담을 수 있을 거라고 생각했지만, 이마저도 부족하여 이를 해결하기 위해 유니코드 3.0부터 보충언어판(Supplementary Plane)을 정의했습니다. 이는 BMP(다국어 기본 평면)의 일부를 상위대행(high surrogates, 1024자)과 하위대행(low surrogates, 1024자)으로 할당한 뒤 이 둘의 조합으로 생겨난 약 `백만자(1024 x 1024 = 1,048,576)`가 넘는 문자를 추가로 정의했습니다.

이로써, 유니코드에는 `65,536(BMP)` + `1,048,576(상, 하위대행의 조합)` - `2,048(상, 하위대행에 사용된 영역)` = `1,112,064자`의 문자를 지정할 수 있게 되었으며, 유니코드는 이를 아래의 표와 같이 17개 구역으로 나눴습니다. (참고로 전체 영역인 1,112,064를 2byte인 65,536으로 나눈 값이 약 16.96이라서 17개 구역인 것 같습니다.)

추가로, 유니코드의 각 문자는 코드포인트라는 숫자에 대응됩니다. 예를 들어 'A'는 U+41에 대응되며, 여기서 U+는 코드포인트라는 의미입니다.

![그림2. 유니코드의 구성 1](/assets/contents/charset-encoding/2.png)

![그림3. 유니코드의 구성 2](/assets/contents/charset-encoding/3.png)

## UTF-8

대체로 유니코드와 UTF 인코딩 방식을 같은 개념으로 생각하는데, **유니코드는 인코딩이 아닙니다.**
유니코드는 전 세계의 모든 문자를 2bytes로 매핑한 방식의 코드표를 의미하며, **이 코드표를 컴퓨터가 이해할 수 있도록 하는 여러 가지 인코딩 방식 중 하나가 UTF-8, UTF-16 등입니다.**
(그래도 구분이 어렵다면 [여기](https://stackoverflow.com/questions/643694/what-is-the-difference-between-utf-8-and-unicode)를 참조하세요.)

**UTF-8(Universal Coded Character Set + Transformation Format – 8 bit)은 유니코드를 위한 가변 길이 인코딩 방식입니다.** 쉽게 말하면 문자마다 byte 크기가 다르다는 의미입니다.

첫 128자는 ASCII 코드 값으로 ANSI와 UTF-8이 동일합니다. 때문에 영어를 사용할 경우 1byte만 사용합니다.
하지만 많은 유럽 지역의 나라들과 중동 지역의 나라들의 언어는 2bytes를 사용하며, 한국, 일본, 중국 등 동아시아권 나라들의 언어는 3bytes 이상을 사용합니다.
UTF-8은 매우 일반적인 인코딩 방식이지만 3bytes 이상의 문자를 사용할 경우에는 비효율적일 수 있습니다.

UTF-16은 16bit 기반으로 저장하는 UTF-8의 변형이라고 보면 됩니다.
한글의 경우 UTF-8로 저장할 경우 3bytes가 필요한데, UTF-16로는 2bytes면 가능해서 용량의 이점이 있습니다. 그러나 특정한 경우에는 2bytes 이상을 사용하기도 해서 용량상의 큰 이점이 있다고 볼 수 없으며, [엔디언](<https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8#:~:text=%EC%97%94%EB%94%94%EC%96%B8(Endianness)%EC%9D%80%20%EC%BB%B4%ED%93%A8%ED%84%B0,(Byte%20order)%EB%9D%BC%20%ED%95%9C%EB%8B%A4.>) 처리를 고려함에 따른 복잡성 증대나 ANSI와 호환이 안되는 단점이 있습니다.

UTF-32는 모든 문자를 4bytes로 인코딩합니다. 문자 변환 알고리즘이나 가변 길이 인코딩 방식에 대한 고민을 하고 싶지 않을 때 유용할 수 있습니다. 그러나 메모리 사용이 비효율적이라서 자주 사용되지는 않습니다.

유니코드를 UTF-8로 인코딩하는 과정은 [여기](https://ko.wikipedia.org/wiki/UTF-8)를 참조하면 됩니다.

## 참조

- https://m.blog.naver.com/ansdbtls4067/220624120433
- https://onlywis.tistory.com/2
- https://stackoverflow.com/questions/643694

<br />
